# JAVASCRIPT
JavaScript был создан в 1995 Бренданом Айком, инженером в компании Netscape. Первый релиз состоялся вместе с выходом браузера Netscape 2 в начале 1996 года. Сначала язык назывался LiveScript, но затем был переименован в связи с маркетинговыми целями, чтобы сыграть на популярности языка Java компании Sun Microsystem — несмотря на это языки практически не имеют ничего общего друг с другом. Так было положено начало путаницы между этими языками.

Чуть позже Microsoft выпустила очень похожий и практически совместимый язык JScript, который шёл вместе с IE3. Через пару месяцев Netscape отправил язык в Ecma International, Европейскую организацию занимающуюся стандартами, которая выпустила первую версию стандарта ECMAScript в 1997. Стандарт получил значимое обновление в ECMAScript edition 3 в 1999, и остаётся самым стабильным до сегодняшнего дня. Четвёртая версия была отклонена, из-за проблем с усложнениями в языке. Многие вещи из четвёртого издания послужили основой для стандарта ECMAScript 5 (декабрь 2009) и ECMAScript 6 (июнь 2015).

## Описание
JavaScript является объектно-ориентированным языком, имеющий типы и операторы, встроенные объекты и методы. Его синтаксис происходит от языков Java и C, поэтому много конструкций из этих языков применимы и к JavaScript. Одним из ключевых отличий JavaScript является отсутствие классов, вместо этого функциональность классов осуществляется прототипами объектов (смотрите ES6 Classes) . Другое главное отличие в том, что функции это объекты, в которых содержится исполняемый код и которые могут быть переданы куда-либо, как и любой другой объект.

Начнём с основы любого языка: с типов данных. Программы на JavaScript оперируют значениями, и все эти значения принадлежат к определённому типу. Типы данных в JavaScript:

  - Числа
  - Строки
  - Логические типы
  - Функции
  - Объекты
  - Символы (новый тип из шестой редакции)

Да, ещё Undefined и Null, которые немного обособлены. И Массивы, которые являются особым видом объектов. А также Даты и Регулярные выражения, тоже являющиеся объектами. И, если быть технически точным, функции это тоже особый вид объекта. Поэтому схема типов выглядит скорее так:

  - Числа (Number)
  - Строки (String)
  - Логические типы (Boolean)
  - Символы (новый тип из шестой редакции)
  - Объекты (Object)
    - Функции
    - Массивы
    - Даты
    - Регулярные выражения
  - Null
  - undefined

Также есть несколько встроенных типов Ошибок. Чтобы было проще, рассмотрим подробнее первую схему.

## Числа
Числа в JavaScript — это "64-битные значения двойной точности формата IEEE 754", согласно спецификации. Это имеет интересные последствия. В JavaScript нет такой вещи, как целое число, поэтому с арифметикой нужно быть начеку, если вы привыкли к вычислениям в языках C или Java. Взгляните на пример:

```
0.1 + 0.2 == 0.30000000000000004
```

На практике целые значения это 32-битные целые (и хранятся таким образом в некоторых браузерных реализациях), что может быть важно для побитовых операций.

Поддерживаются стандартные арифметические операторы, включая сложение, вычитание, остаток от деления и т.д. Есть ещё встроенный объект, который я забыл упомянуть, называемый Math, который содержит более продвинутые математические функции и константы:

```
Math.sin(3.5);
```

Вы можете преобразовать строку в целое число, используя встроенную функцию parseInt(). Её необязательный второй параметр — основание системы счисления, которое следует всегда явно указывать:

```
parseInt("123", 10); // 123
```

Специальное значение NaN (сокращение от "Not a Number") возвращается, если строка не является числом:

```
parseInt("hello", 10); // NaN

NaN + 5; // NaN

isNaN(NaN); // true
```

## Строки
Строки в JavaScript - это последовательности символов Unicode (в кодировке UTF-16).

```
"hello".length; // 5
```

Это уже первый шаг для работы с объектами! Мы уже говорили, что и строки можно использовать как объекты? У них тоже есть методы:

```
"hello".toUpperCase(); // HELLO
```

## Другие типы
JavaScript дополнительно различает такие типы, как null, который указывает на преднамеренное отсутствующее значение, и undefined, указывающий на неинициализированное значение — то есть, значение, которое даже не было назначено. Мы поговорим о переменных позже, но в JavaScript можно объявить переменную без присвоения ей значения. В этом случае тип переменной будет "undefined".

Ещё в JavaScript есть логический (булевый) тип данных, который может принимать два возможных значения true или false (оба являются ключевыми словами). Любое значение может быть преобразовано в логическое значение в соответствии со следующими правилами:

  1. false, 0, пустая строка (""), NaN, null и undefined преобразуются в false.
  2. Все остальные значения преобразуются в true.

Преобразование значений можно осуществить явно, используя функцию Boolean():

```
Boolean(""); // false
Boolean(234); // true
```

Этот метод используется редко, так как JavaScript может автоматически преобразовывать типы в тех случаях, когда ожидается булевое значение, например в операторе `if`. Из-за того, что любой тип данных может быть преобразован в булевое значение, иногда говорят, что данные "истинные" или "ложные".

Для операций с логическими данными используются логические операторы: `&&` (логическое И), `||` (логическое ИЛИ), `!` (логическое НЕ).

## Динамическая типизация
JavaScript является слабо типизированным или динамическим языком. Это значит, что вам не нужно определять тип переменной заранее. Тип определится автоматически во время выполнения программы. Также это значит, что вы можете использовать одну переменную для хранения данных различных типов:

```
var foo = 42; // сейчас foo типа Number
foo = "bar"; // а теперь foo типа String
foo = true;  // foo становится типа Boolean
```

## Переменные
Для объявления новых переменных в  JavaScript используются ключевые слова `let`, `const` или `var`.

```
let a;
let name = "Simon";
```

`let`  позволяет объявлять переменные, которые доступны только в **блоке**, в котором они объявлены:

```
// myLetVariable недоступна здесь

for (let myLetVariable = 0; myLetVariable < 5; myLetVariable++) {
  // myLetVariable доступна только здесь
}

// myLetVariable недоступна здесь
```

`const` позволяет создавать переменные, чьи значения не предполагают изменений. Переменная доступна из **блока**, в котором она объявлена.

```
const Pi = 3.14; // в переменную Pi записано значение.
Pi = 1; // вызовет исключение, так как значение константы нельзя изменить.
```

`var` наиболее общее средство объявления переменной. Оно не имеет ограничений, которые имеют два вышеописанных способа. Это потому, что это был изначально единственный способ объявления переменной в JavaScript. Переменная, объявленная с помощью `var`, доступна в пределах **функции**, в которой она объявлена.

```
var a;
var name = 'Simon';
```

Пример кода с переменной, объявленной с помощью `var`:

```
// myVarVariable доступна здесь

for (var myVarVariable = 0; myVarVariable < 5; myVarVariable++) {
  // myVarVariable доступна для всей функции
}

// myVarVariable доступна и здесь
```

Если вы объявляете переменную без присвоения ей какого-либо значения, то её тип будет определён как undefined. 

## Операторы
JavaScript поддерживает такие операторы, как `+`, `-`, `*`, `/` и `%`, который возвращает остаток от деления.

```
x += 5
x = x + 5
```

Оператор `+` так же выполняет конкатенацию (объединение) строк:

```
"hello" + " world"; // "hello world"
```

При сложении строкового и числового значений происходит автоматическое преобразование в строку. Поначалу такое может запутать:

```
"3" + 4 + 5; // "345"
3 + 4 + "5"; // "75"
```

Для приведения значения к строке просто прибавьте к нему пустую строку.

## Объекты
Объекты в JavaScript представляют собой коллекции пар имя-значение (ключ-значение). Они похожи на:

  - Словари в Python.
  - Хеши в Perl и Ruby.
  - Таблицы хешей в C и C++.
  - HashMaps в Java.
  - Ассоциативные массивы в PHP.

Именем свойства объекта в JavaScript выступает строка, а значением может быть любой тип данных JavaScript, даже другие объекты. Это позволяет создавать структуры данных любой сложности.

Существует два основных способа создать объект:

```
var obj = new Object();
```

А также:

```
var obj = {};
```

Обе эти записи делают одно и то же. Вторая запись называется литералом объекта и более удобная. Такой способ является основой формата JSON, и при написании кода лучше использовать именно его.

С помощью литерала объекта можно создавать не только пустые объекты, но и объекты с данными:

```
var obj = {
  name: "Carrot",
  "for": "Max",
  details: {
    color: "orange",
    size: 12
  }
}
```

Доступ к свойствам объекта можно получить следующими способами:

```
obj.details.color; // orange
obj['details']['size']; // 12
```

Эти два метода равнозначны. Первый метод используется, если мы точно знаем к какому методу нам нужно обратиться. Второй метод принимает в качестве имени свойства строку, и позволяет вычислять имя в процессе вычислений. Следует отметить, что последний метод мешает некоторым движкам и минимизаторам оптимизировать код. Если появится необходимость назначить в качестве имён свойств объекта зарезервированные слова, то данный метод тоже может пригодиться:

```
// Вызовет Syntax error, ведь 'for' это зарезервированное слово
obj.for = "Simon";

// А тут всё нормально
obj["for"] = "Simon";
```

> Начиная с ECMAScript 2015, ключи объектов могут быть определены переменными с  использованием квадратных скобок при создании: {[phoneType]: 12345} допустимо вместо  var userPhone = {}; userPhone[phoneType] = 12345.

## Массивы
Массивы в JavaScript всего лишь частный случай объектов. Работают они практически одинаково (если именем свойства является число, то доступ к нему можно получить только через вызов в скобках []), только у массивов есть одно удивительное свойство `'length'` (длина). Оно возвращает число, равное самому большому индексу массива + 1.

Создать массив можно по старинке:

```
var a = new Array();
a[0] = "dog";
a[1] = "cat";
a[2] = "hen";
a.length; // 3
```

Но гораздо удобнее использовать литерал массива:

```
var a = ["dog", "cat", "hen"];
a.length; // 3
```

Запомните, свойство array.length не обязательно будет показывать количество элементов в массиве. Посмотрите пример:

```
var a = ["dog", "cat", "hen"];
a[100] = "fox";
a.length; // 101
```

Запомните — длина массива это его самый большой индекс плюс один.

Если попытаться получить доступ к несуществующему элементу массива, то получите `undefined`:

```
typeof a[90]; // undefined
```

Для перебора элементов массива используйте такой способ:

```
for (var i = 0; i < a.length; i++) {
    // Сделать что-нибудь с элементом a[i]
}
```

ES2015 представляет более краткий for...of способ обхода по итерируемым объектам, в т.ч. массивам:

```
for (const currentValue of a) {
  // Сделать что-нибудь с currentValue
}
```

Перебрать элементы массива также можно с помощью цикла for...in. Но, если вдруг будет изменено какое-либо свойство Array.prototype, то оно тоже будет участвовать в выборке. Не используйте данный метод.

И самый новый способ перебора свойств массива был добавлен в ECMAScript 5 — это метод `forEach()`:

```
["dog", "cat", "hen"].forEach(function(currentValue, index, array) {
// Сделать что-нибудь с currentValue или array[index]
});
```

Для добавления данных в массив используйте метод push():

```
a.push(item);
```

## Функции
Наряду с объектами функции также являются ключевыми компонентами языка JavaScript. Базовые функции очень просты:

```
function add(x, y) {
    var total = x + y;
    return total;
}
```

В этом примере показано практически всё, что нужно знать о функциях. Функции в JavaScript могут принимать ноль или более параметров. Тело функции может содержать любые выражения и определять свои собственные переменные, которые будут для этой функции локальными. Инструкция return используется для возврата значения и остановки выполнения функции. Если инструкции return в функции нет (или есть, но не указано возвращаемое значение), то JavaScript возвратит undefined.

Можно вызвать функцию, вообще не передавая ей параметры. В таком случае будет считаться, что их значения равны undefined:

```
add(); // NaN
// Нельзя проводить сложение undefined и undefined
```

Можно передать больше аргументов, чем ожидает функция:

```
add(2, 3, 4); // 5
// используются только первые два аргумента, "4" игнорируется
```

Это может показаться бессмысленным, но на самом деле функции могут получить доступ к "лишним" аргументам с помощью псевдомассива arguments, в нём содержатся значения всех аргументов, переданных функции. Давайте напишем функцию, которая принимает неограниченное количество аргументов:

```
function add() {
    var sum = 0;
    for (var i = 0, j = arguments.length; i < j; i++) {
        sum += arguments[i];
    }
    return sum;
}

add(2, 3, 4, 5); // 14
```

Или создадим функцию для вычисления среднего значения:

```
function avg() {
    var sum = 0;
    for (var i = 0, j = arguments.length; i < j; i++) {
        sum += arguments[i];
    }
    return sum / arguments.length;
}
avg(2, 3, 4, 5); // 3.5
```