# JAVASCRIPT

## Введение в события
События — это действия или события, происходящие в системе, которую вы программируете, о которых система сообщает вам, чтобы ваш код мог реагировать на них.

В случае Интернета события запускаются внутри окна браузера и, как правило, привязаны к определенному элементу, который находится в нем. Это может быть отдельный элемент, набор элементов, HTML-документ, загруженный на текущей вкладке, или все окно браузера. Возможны различные типы событий.

Например:

  - Пользователь выбирает, щелкает или наводит курсор на определенный элемент.
  - Пользователь выбирает клавишу на клавиатуре.
  - Пользователь изменяет размер или закрывает окно браузера.
  - Веб-страница завершает загрузку.
  - Отправляется форма.
  - Видео воспроизводится, приостанавливается или завершается.
  - Возникает ошибка.

Вы можете понять из этого (и из [справочника](https://developer.mozilla.org/en-US/docs/Web/Events) событий MDN), что существует множество событий, которые могут быть запущены.

Чтобы отреагировать на событие, вы прикрепляете к нему **обработчик событий** (event handler) . Это блок кода (обычно это функция JavaScript, которую вы, как программист, создаете), который запускается при возникновении события. Когда такой блок кода определен для запуска в ответ на событие, мы говорим, что **регистрируем обработчик события**. Примечание. Обработчики событий иногда называют **прослушивателями событий** (event listener) — для наших целей они в значительной степени взаимозаменяемы, хотя, строго говоря, они работают вместе. Слушатель прослушивает происходящее событие, а обработчик — это код, который запускается в ответ на это событие.

> *Примечание*: Веб-события не являются частью основного языка JavaScript — они определяются как часть API, встроенных в браузер.

### Простой пример
Давайте посмотрим на простой пример того, что мы имеем в виду. В следующем примере у нас есть один `<button>`, при нажатии которого фон меняется на случайный цвет:

```
<button>Change color</button>
```


JavaScript выглядит так:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

function changeBackground() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}
```

В этом коде мы сохраняем ссылку на `<button>` элемент внутри константы с именем btn, используя `Document.querySelector()` функцию.

Мы также определяем функцию, которая возвращает случайное число.

### Использование `addEventListener()`

Рекомендуемым механизмом добавления обработчиков событий на веб-страницы является метод `addEventListener()`:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

function changeBackground() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}

btn.addEventListener('click', changeBackground);
```

Внутри функции `addEventListener()` мы указываем два параметра: имя события, для которого мы хотим зарегистрировать этот обработчик, и код, содержащий функцию-обработчик, которую мы хотим запустить в ответ на него.

Можно сделать функцию-обработчик и анонимной функцией.

 События не уникальны для JavaScript — в большинстве языков программирования есть какая-то модель событий, и способ работы этой модели часто отличается от того, как работает JavaScript. На самом деле модель событий в JavaScript для веб-страниц отличается от модели событий для JavaScript, поскольку она используется в других средах.

### Прослушивание других событий

Существует множество различных событий, которые могут быть запущены элементом кнопки. Давайте экспериментировать.

Сначала сделайте локальную копию random-color-addeventlistener.html и откройте ее в браузере. Это просто копия простого примера случайного цвета, с которым мы уже играли. Теперь попробуйте `click` по очереди изменить следующие значения и понаблюдайте за результатами в примере:

  - `focus` и `blur` — цвет меняется, когда кнопка сфокусирована и не сфокусирована; попробуйте нажать вкладку, чтобы сфокусироваться на кнопке, и снова нажать вкладку, чтобы сфокусироваться от кнопки. Они часто используются для отображения информации о заполнении полей формы, когда они находятся в фокусе, или отображения сообщения об ошибке, если поле формы заполнено неправильным значением.
 - `dblclick` — Цвет меняется только при двойном нажатии кнопки.
 - `mouseover` и `mouseout` — цвет изменяется при наведении указателя мыши на кнопку или при перемещении указателя с кнопки соответственно.

Некоторые события, такие как `click`, доступны практически для любого элемента. Другие более специфичны и полезны только в определенных ситуациях: например, событие `play` доступно только для некоторых элементов, таких как `<video>`.

### Удаление слушателей

Если вы добавили обработчик событий с помощью `addEventListener()`, вы можете снова удалить его с помощью метода `removeEventListener()`. Например, это удалит обработчик `changeBackground()`:

```
btn.removeEventListener('click', changeBackground);
```

Обработчики событий также можно удалить, передав объект `AbortSignal` в `addEventListener()`, а затем при вызове `abort()` у контроллера, владеющего `AbortSignal`. Например, чтобы добавить обработчик событий, который мы можем удалить с помощью `AbortSignal`:

```
const controller = new AbortController();

btn.addEventListener('click', () => {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}, { signal: controller.signal }); // pass an AbortSignal to this handler
```

Затем обработчик событий, созданный приведенным выше кодом, можно удалить следующим образом:

```
controller.abort(); // removes any/all event handlers associated with this controller
```

Для простых, небольших программ очистка старых, неиспользуемых обработчиков событий не требуется, но для более крупных и сложных программ это может повысить эффективность. Кроме того, возможность удалять обработчики событий позволяет использовать одну и ту же кнопку для выполнения разных действий в разных обстоятельствах: все, что вам нужно сделать, это добавить или удалить обработчики.

### Добавление нескольких прослушивателей для одного события

Делая более одного вызова `addEventListener()` и предоставляя разные обработчики, вы можете иметь несколько обработчиков для одного события:

```
myElement.addEventListener('click', functionA);
myElement.addEventListener('click', functionB);
```

Обе функции теперь будут запускаться при нажатии на элемент.

**Изучайте больше**

Существуют и другие мощные функции и параметры, доступные в `addEventListener()`, для этого посетите страницы [addEventListener()](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) и [removeEventListener()](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener).

## Другие механизмы прослушивания событий
В общем рекомендуется использовать `addEventListener()` для регистрации обработчиков событий. Это самый мощный метод, который лучше всего подходит для более сложных программ. Однако есть два других способа регистрации обработчиков событий, которые вы можете использовать: *свойства обработчика* событий и *встроенные обработчики событий*.

## Свойства обработчика событий
Объекты (например, кнопки), которые могут запускать события, также обычно имеют свойства, за именем которых `on` следует имя события. Например, элементы имеют свойство `onclick`. Это называется свойством обработчика событий. Чтобы прослушать событие, вы можете назначить функцию-обработчик свойству.

Например, мы могли бы переписать пример со случайным цветом следующим образом:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

btn.onclick = () => {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}
```

Вы также можете установить свойство обработчика на именованную функцию:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

function bgChange() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}

btn.onclick = bgChange;
```

С помощью свойств обработчика событий вы не можете добавить более одного обработчика для одного события. Например, вы можете вызывать `addEventListener('click', handler)` элемент несколько раз с разными функциями, указанными во втором аргументе:

```
element.addEventListener('click', function1);
element.addEventListener('click', function2);
```

Это невозможно со свойствами обработчика событий, потому что любые последующие попытки установить свойство перезапишут более ранние:

```
element.onclick = function1;
element.onclick = function2;
```

### Встроенные обработчики событий — не используйте их
Вы также можете увидеть подобный шаблон в своем коде:

```
<button onclick="bgChange()">Press me</button>
```

```
function bgChange() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}
```

Самый ранний метод регистрации обработчиков событий, найденный в Интернете, включал HTML-атрибуты обработчика событий (или встроенные обработчики событий), подобные показанному выше — значением атрибута буквально является код JavaScript, который вы хотите запустить при возникновении события. В приведенном выше примере вызывается функция, определенная внутри элемента `<script>` на той же странице, но вы также можете вставить JavaScript непосредственно в атрибут, например:

```
<button onclick="alert('Hello, this is my old-fashioned event handler!');">Press me</button>
```

Вы можете найти эквиваленты атрибутов HTML для многих свойств обработчиков событий; однако вы не должны использовать их — это считается плохой практикой. Может показаться простым использовать атрибут обработчика событий, если вы делаете что-то очень быстро, но они быстро становятся неуправляемыми и неэффективными.

Для начала не рекомендуется смешивать HTML и JavaScript, так как их становится трудно читать. Хранение вашего JavaScript отдельно является хорошей практикой, и если он находится в отдельном файле, вы можете применить его к нескольким HTML-документам.

Даже в одном файле встроенные обработчики событий — не лучшая идея. Одна кнопка — это нормально, но что, если бы у вас было 100 кнопок? Вам нужно будет добавить в файл 100 атрибутов; это быстро превратилось бы в кошмар обслуживания. С помощью JavaScript вы можете легко добавить функцию обработчика событий ко всем кнопкам на странице, сколько бы их ни было, используя что-то вроде этого:

```
const buttons = document.querySelectorAll('button');

for (const button of buttons) {
  button.addEventListener('click', bgChange);
}
```

Наконец, многие распространенные конфигурации серверов запрещают встроенный JavaScript в качестве меры безопасности.

**Вы никогда не должны использовать атрибуты обработчика событий HTML** — они устарели, и их использование — плохая практика.

## Объекты событий
Иногда внутри функции обработчика событий вы увидите параметр, указанный с таким именем, как `event`, `evt` или `e`. Он называется объектом события и автоматически передается обработчикам событий для предоставления дополнительных функций и информации. Например, давайте снова немного перепишем наш случайный пример цвета:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

function bgChange(e) {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  e.target.style.backgroundColor = rndCol;
  console.log(e);
}

btn.addEventListener('click', bgChange);
```

Здесь вы можете видеть, что мы включаем объект события, `e` , в функцию и в функцию, устанавливающую стиль цвета фона, `e.target` который является самой кнопкой. Свойство `target` объекта события всегда является ссылкой на элемент, с которым произошло событие. Итак, в этом примере мы устанавливаем случайный цвет фона для кнопки, а не для страницы.

### Дополнительные свойства объектов событий
Большинство объектов событий имеют стандартный набор свойств и методов, доступных для объекта события (полный список см. в [справочнике](https://developer.mozilla.org/en-US/docs/Web/API/Event) по объектам).

Некоторые объекты событий добавляют дополнительные свойства, относящиеся к этому конкретному типу событий. Например, событие `keydown` срабатывает, когда пользователь нажимает клавишу. Его объект события`KeyboardEvent` —  это специализированный `Event` объект со свойством `key`, сообщающим, какая клавиша была нажата:

```
<input id="textBox" type="text">
<div id="output"></div>
```

```
const textBox = document.querySelector("#textBox");
const output = document.querySelector("#output");
textBox.addEventListener('keydown', (event) => output.textContent = `You pressed "${event.key}".`);
```

Попробуйте ввести текст в текстовое поле и посмотрите вывод.

### Предотвращение поведения по умолчанию
Иногда вы столкнетесь с ситуацией, когда вы хотите, чтобы событие не выполняло то, что оно делает по умолчанию. Наиболее распространенным примером является веб-форма, например, пользовательская регистрационная форма. Когда вы вводите данные и нажимаете кнопку «Отправить», естественным поведением является отправка данных на указанную страницу на сервере для обработки, а браузер перенаправляется на какую-либо страницу «сообщения об успешном завершении» (или той же странице, если не указан другой.)

Проблема возникает, когда пользователь не отправил данные правильно — как разработчик, вы хотите предотвратить отправку на сервер и выдать сообщение об ошибке, говорящее, что не так и что нужно сделать, чтобы все исправить. Некоторые браузеры поддерживают функции автоматической проверки данных формы, но, поскольку многие из них этого не делают, рекомендуется не полагаться на них и реализовать собственные проверки проверки. Давайте рассмотрим простой пример.

Во-первых, простая HTML-форма, которая требует ввода вашего имени и фамилии:

```
<form>
  <div>
    <label for="fname">First name: </label>
    <input id="fname" type="text">
  </div>
  <div>
    <label for="lname">Last name: </label>
    <input id="lname" type="text">
  </div>
  <div>
     <input id="submit" type="submit">
  </div>
</form>
<p></p>
```

Теперь немного JavaScript — здесь мы реализуем очень простую проверку внутри обработчика события `submit` (событие отправки запускается в форме при ее отправке), которая проверяет, пусты ли текстовые поля. Если это так, мы вызываем функцию `preventDefault()` объекта события, которая останавливает отправку формы, а затем отображаем сообщение об ошибке в абзаце под нашей формой, чтобы сообщить пользователю, что не так:

```
const form = document.querySelector('form');
const fname = document.getElementById('fname');
const lname = document.getElementById('lname');
const para = document.querySelector('p');

form.addEventListener('submit', (e) => {
  if (fname.value === '' || lname.value === '') {
    e.preventDefault();
    para.textContent = 'You need to fill in both names!';
  }
});
```

Очевидно, что это довольно слабая проверка формы — она не помешает пользователю проверять форму, например, с пробелами или числами, введенными в поля, — но для примера это нормально.

### Всплывание и захват событий
Всплывающие события и захват — это термины, описывающие этапы обработки браузером событий, направленных на вложенные элементы.

**Установка слушателя на родительском элементе**

Рассмотрим такую ​​веб-страницу:

```
<div id="container">
  <button>Click me!</button>
</div>
<pre id="output"></pre>
```

Здесь кнопка находится внутри другого элемента `<div>`. Мы говорим, что `<div>` элемент здесь является родителем элемента, который он содержит. Что произойдет, если мы добавим обработчик события клика к родителю, а затем нажмем кнопку?

```
const output = document.querySelector('#output');
function handleClick(e) {
  output.textContent += `You clicked on a ${e.currentTarget.tagName} element\n`;
}

const container = document.querySelector('#container');
container.addEventListener('click', handleClick);
```

Вы увидите, что родитель запускает событие щелчка, когда пользователь нажимает кнопку:

```
You clicked on a DIV element
```

Это имеет смысл: кнопка находится внутри `<div>`, поэтому, когда вы нажимаете кнопку, вы также неявно щелкаете элемент, внутри которого она находится.

**Пример всплывающего окна**

Что произойдет, если мы добавим прослушиватели событий к кнопке и родителю?

```
<body>
  <div id="container">
    <button>Click me!</button>
  </div>
  <pre id="output"></pre>
</body>
```

Давайте попробуем добавить обработчики событий клика к кнопке, ее родителю ( `<div>`) и элементу `<body>`, содержащему их оба:

```
const output = document.querySelector('#output');
function handleClick(e) {
  output.textContent += `You clicked on a ${e.currentTarget.tagName} element\n`;
}

const container = document.querySelector('#container');
const button = document.querySelector('button');

document.body.addEventListener('click', handleClick);
container.addEventListener('click', handleClick);
button.addEventListener('click', handleClick);
```

Вы увидите, что все три элемента запускают событие клика, когда пользователь нажимает кнопку:

```
You clicked on a BUTTON element
You clicked on a DIV element
You clicked on a BODY element
```

В таком случае:

  - нажатие на кнопку срабатывает первым
  - с последующим щелчком по его родителю ( <div>элементу)
  - за которым <div>следует родитель элемента ( <body>элемент).

Мы описываем это, говоря, что событие всплывает (bubbles) из самого внутреннего элемента, по которому был сделан щелчок.

Такое поведение может быть полезным, а также может вызвать непредвиденные проблемы. В следующем разделе мы увидим проблему, которую она вызывает, и найдем решение.

**Пример видеоплеера**

Этот пример показывает и скрывает `<div>` с `<video>` элементом внутри него:

```
 <style>
      div {
        position: absolute;
        top: 50%;
        transform: translate(-50%,-50%);
        width: 480px;
        height: 380px;
        border-radius: 10px;
        background-color: #eee;
        background-image: linear-gradient(to bottom, rgba(0,0,0,0), rgba(0,0,0,0.1));
      }

      .hidden {
        left: -50%;
      }

      .showing {
        left: 50%;
      }

      div video {
        display: block;
        width: 400px;
        margin: 40px auto;
      }

    </style>

<button>Display video</button>

<div class="hidden">
  <video>
    <source src="https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.mp4" type="video/mp4">
    <source src="https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.webm" type="video/webm">
    <p>Your browser doesn't support HTML5 video. Here is a <a href="rabbit320.mp4">link to the video</a> instead.</p>
  </video>
</div>
```

Когда `<button>` щелкают, видео отображается путем изменения атрибута `class` в `<div>` с `hidden` на `showing` (CSS примера содержит эти два класса, которые размещают блок за пределами экрана и на экране соответственно):

```
const btn = document.querySelector('button');
const videoBox = document.querySelector('div');

function displayVideo() {
  if (videoBox.getAttribute('class') === 'hidden') {
    videoBox.setAttribute('class','showing');
  }
}

btn.addEventListener('click', displayVideo);
```

Затем мы добавляем еще пару обработчиков событий `click` — первый к `<div>`, а второй к `<video>`:

```
videoBox.addEventListener('click', () => videoBox.setAttribute('class', 'hidden'));

const video = document.querySelector('video');

video.addEventListener('click', () => video.play());
```

Теперь, когда щелкнут область за пределами `<div>` видео, поле должно снова быть скрыто, а когда щелкнут само видео, видео должно начать воспроизводиться.

Но есть проблема — в настоящее время, когда вы нажимаете на видео, оно начинает воспроизводиться, но `<div>` в то же время скрывается. Это связано с тем, что видео находится внутри `<div>` — оно является его частью — поэтому нажатие на видео фактически запускает оба вышеуказанных обработчика событий.

**Объяснение всплытия и захвата**

Когда событие запускается для элемента, у которого есть родительские элементы (в данном случае, у элемента `<video>` есть родитель `<div>`), современные браузеры выполняют три разных этапа — этап **захвата** (capturing phase), этап **таргетирования** (target phase) и этап **всплытия** (bubbling phase).

На этапе **захвата** :

  - Браузер проверяет, зарегистрирован ли на самом внешнем предке элемента ( `<html>`) обработчик событий `click` для фазы захвата, и запускает его, если это так.
  - Затем он переходит к следующему элементу внутри <html>и делает то же самое, затем к следующему и так далее, пока не достигнет прямого родителя элемента, по которому фактически был сделан щелчок.

В **целевой** фазе:

  - Браузер проверяет, есть ли у свойства `target` обработчик событий для `click` и запускает его, если это так.
  - Затем, если `bubbles` равно `true`, событие передается непосредственному родителю выбранного элемента, затем следующему и так далее, пока не достигнет `<html>` элемента. В противном случае, если `bubbles` равен false, событие не передается никаким предкам цели.

В фазе **всплытия** происходит полная противоположность фазе захвата :

  - Браузер проверяет, зарегистрирован ли обработчик событий `click` для непосредственного родителя выбранного элемента, и запускает его, если это так.
  - Затем он переходит к следующему непосредственному элементу-предку и делает то же самое, затем к следующему и так далее, пока не достигнет `<html>` элемента.

В современных браузерах по умолчанию все обработчики событий регистрируются для фазы всплытия. Таким образом, в нашем текущем примере, когда вы нажимаете на видео, событие всплывает от `<video>` элемента наружу к `<html>` элементу. По пути:

  - Он находит обработчик `click` `video` элемента и запускает его, поэтому сначала начинает воспроизводиться видео.
  - Затем он находит обработчик `click` `videoBox` элемента и запускает его, поэтому видео также скрывается.

**Исправление проблемы с `stopPropagation()`**

Как мы видели в примере с видео, это может быть очень раздражающим поведением, но есть способ предотвратить это! Стандартный объект `Event` имеет доступную для него функцию `stopPropagation()`, которая при вызове объекта события обработчика делает так, что первый обработчик запускается, но событие не всплывает дальше по цепочке, поэтому больше обработчики не будут запущены.

Таким образом, мы можем решить нашу текущую проблему, изменив вторую функцию-обработчик в предыдущем блоке кода на это:

```
video.addEventListener('click', (e) => {
  e.stopPropagation();
  video.play();
});
```
